1. Делим текст на последовательность абзацев через разделитель \n\n
2. Делим абзацы на слова разделителем [^\w]+
3. Тестим что уникодовые буквы это \w
4. Получаем 
    document = List Paragraph
    Paragraph = List Word
4.1. Поскольку входные файлы у нас на известных языках, помечаем параграфы именем файла (для валидации)
5. Смотрим на каждый Word
 например:
    $Hamlet^
6. Здесь $ символ начала слова, ^ символ конца слова
7. Делим слово на последовательность 2х букв
 $H, Ha, am, ml, le, et, t^
8. Цель: для каждой последовательности из 2х букв (слога) посчитать количество раз, которое оно встречается в каждом абзаце.
9. Для нормализации, данные количества делятся в конце на их общее число в каждом абзаце и получаем их эмпирические вероятности.
10. Абзацы короткие, а кол-во комбинаций для 30 букв будет 30*29 = 900. При этом в 10 строках текста по 80 букв 800 букв=799 комбинаций. 
Поэтому надо длинные абзеацы.
11. Получим таблицу

            $H,     Ha,     am,     ml,     le,     et,     t^
абзац-1     0.0     0.1     0.0     0.1     0.5     0.2     0.3
абзац-2     0.5     0.2     0.0     0.1     0.5     0.2     0.3

12. Комбинации пар символов это признаки, имеющие вещественное значение в диапазоне [0,1)
13. Наша задача теперь разделить рих на классы.
14. Для этого будем постепенно увеличивать число классов от 2 до 10, и будем строить график ошибки (суммы (по кластерам) квадрата расстояния членов кластера до его центра)
15. График должен быть монотонно убывающей функцией, наша задача выбрать такое число кластеров, 
чтобы увеличение их на один уменьшало ошибку менее чем на некий порог (относительно предыдущей).
16. Алгоритм k-means для выбраного k берем из станадртной библиотеки питона.
17. Если тест будет удачный, переписываем на c++.
18. После кластеризации каждый Paragraph получает номер класса klass.
19. Поскольку язык соотвествует 1-в-1 имени файла, то можем подсчитать ошибки. 

```
 klass, paragraphs(klass) = paragraps.group_by(klass)
 hist(klass) = paragraphs(klass).histogram_by(p: p.klass)
```
Это Дает распределение имен файлов в классе. Если будет получаться, что в классе доминирует один язык, то получен качественный класс.
Численно метрика ошибки есть доля не-доминирующих языков в кластере.

20. Также может получиться, что 
20.1. классов слишком мало (тогда доля не доминирующих языков будет высокой по некоторым кластерам)
20.2. классов слишком много (тогда будет много классов где доминирует определенный язык).
21. Поэтому метриками качества класса выберем 
klass->dominant_filename_share(klass)
filename->number_of_dominant_klasses(filename)
Ясно что по каждому языку идеальное число доминирующих классов должно быть равно 1
И в каждом классе доля доминирующего языка должна быть близка к 1
22. Изначально входные параметры - это макс число языков с латинским алфавитом K_MAX. Перебираем число классов не превосходящее K_MAX
23. Если все будет плохо, то надо будет работать над функцией дистанции. Для чего надо делать для известных языков попарный SVM (повернуть пространство признаков)
После чего можно придать меньший вес тем признакам которые лежат в разделяющей гиперплоскости (при вычислении дистанций), но это уже перебор.
24. Если признаков будет слишком много (900) то можно перейти к 1 буквенной статистике.

